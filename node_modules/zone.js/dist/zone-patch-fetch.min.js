!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n():"function"==typeof define&&define.amd?define(n):n()}(0,function(){"use strict";Zone.__load_patch("fetch",function(t,n,o){var e=t.fetch;if("function"==typeof e){var r=t[o.symbol("fetch")];r&&(e=r);var c=t.Promise,l=o.symbol("thenPatched"),a=o.symbol("fetchTaskScheduling"),f=o.symbol("fetchTaskAborting"),i=t.AbortController,u="function"==typeof i,s=null;u&&(t.AbortController=function(){var t=new i;return t.signal.abortController=t,t},s=o.patchMethod(i.prototype,"abort",function(t){return function(n,o){return n.task?n.task.zone.cancelTask(n.task):t.apply(n,o)}}));var h=function(){};t.fetch=function(){var t=this,r=Array.prototype.slice.call(arguments),i=r.length>1?r[1]:null,d=i&&i.signal;return new Promise(function(i,p){var b=n.current.scheduleMacroTask("fetch",h,{fetchArgs:r},function(){var f,u=n.current;try{u[a]=!0,f=e.apply(t,r)}catch(t){return void p(t)}finally{u[a]=!1}if(!(f instanceof c)){var s=f.constructor;s[l]||o.patchThen(s)}f.then(function(t){"notScheduled"!==b.state&&b.invoke(),i(t)},function(t){"notScheduled"!==b.state&&b.invoke(),p(t)})},function(){if(u)if(d&&d.abortController&&!d.aborted&&"function"==typeof d.abortController.abort&&s)try{n.current[f]=!0,s.call(d.abortController)}finally{n.current[f]=!1}else p("cancel fetch need a AbortController.signal");else p("No AbortController supported, can not cancel fetch")});d&&d.abortController&&(d.abortController.task=b)})}}})});